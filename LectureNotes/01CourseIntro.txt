What motivated me to design this book? There are already many great books on programming languages. Existing books on programming languages can teach you how to use advanced programming language features, implement languages, reason about the mathematical theories underlying languages, reason rigorously about correctness, and so much more. Experts in human-centered computing have written countless books of their own, which can cover that topic in far greater depth than a book that approaches human-centered computing through the lens of programming languages. Why, then, does the world need a book that puts these two perspectives together?

The answer is that this book was created to address the core challenge I face in teaching the programming languages electives at WPI: modern students deserve a course and a book which address programming languages as a breadth topic. My students will go on to a wide range of careers: many will be professional programmers, some will transition into a job where their computer science knowledge takes on a background role as it informs their knowledge of the world around them, and some will continue down the academic road. I want this book to provide something for all of them, whether graduate or undergraduate, computer science major or not. The breadth approach accomplishes this. Breadth is also best-suited for the realities of the digital age. If an alum forgets the details of a classic algorithm five years after graduation, they can always look it up, but if a student graduates without being shown the breadth of the discipline, they might never think to go looking for what they need.
At the same time, this book will not be devoid of classic algorithms and classic results; a breadth approach includes these, but does so in moderation. In fact, we will start narrowly with the classics, teaching core technologies used for language implementation and core vocabulary for technical discussion of languages, then branch out into an increasingly humanistic approach, incorporating human-centered works which do everything from perform user studies to guide language iteration to employ humanistic critiques to consider the role of programming languages in contemporary social issues. We will have a little fun along the way, using programming languages for creative expression as case studies in how the disciplinary and interdisciplinary sides of mind can collaborate in the work of programming language design. At times, this book will depart from the norms of the textbook genre by incorporating small novel research results or *autoethnographic* experiences from the author's life. When we do so, the discussion will remain scholarly. Learning how to explore previously-unexplored ideas and how to bring one's own experience into a rigorous academic experience are both part of a complete education.

This book is designed in the paradigm of open education, meaning the author publishes the full teaching materials openly so that self-taught students can engage on their own and so that educators at other institutions can easily incorporate this work into their own. In addition to the typical exercises presented in textbooks, this book includes recommendations for more comprehensive assignments or projects, as well as direct suggestions for activities that teachers can perform in a classroom. These recommendations serve a dual purpose to the author's students at WPI, to help them prepare for an active class session and get the most out of it. Only solutions to WPI homework assignments are left unpublished, and instructors elsewhere are encouraged to contact the author for access. Though solutions are unpublished, autograding code for assignments is intentionally published because this approach is closest to real-world practice. Real-world programmers often debug their code by exploring its behavior on a variety of test cases, so this skill is valuable use of a student's time, but guessing at the grader's inner workings or intentions would distract from the heart of the educational experience.

For students in the accompanying course: in keeping with this spirit, we will engage with, but not fully commit to, an educational philosophy called *ungrading*, a philosophy that says traditional grades are counterproductive in that they replace a student's natural intrinsic motivation for the submit with the external motivation to optimize for high grades. The exact grading structures will vary from year to year and students should always consult the latest syllabus, but in general I seek to strike a balance between students' desire for me to provide them with a source of external accountability and my desire to provide space for free exploration of aspects that interest you. On that note, the references at the end of each chapter are not merely good scholarly practice, but they are an opportunity for you to dig further in the topics that most interest you and to engage with the latest research on the subject.

When I tell students about programming languages, their first question is often "which language?" On one hand, the differences between different programming languages do matter in a significant way, otherwise we would not study these differences. On the other hand, there is no one right language, not only because different languages are best-suited to different needs of different programmers, but because there is significant cross-pollination between modern languages, and the most important programming language features often reoccur across many modern languages. Different languages are used in different courses or even different iterations of the same course for logistical reasons, so the majority of this book is written in a language-neutral way. As separate chapters, I include primers on several languages that are appropriate for use in a programming languages course. Though there is no perfect language, it is important to provide background material for some language, to support you in implementing the programming language technologies discussed throughout the chapters on language implementation. The exercises attached to those chapters will encourage you to record your experiences with the given language and to reflect and interpret those experiences.

The human-centered nature of this book is fundamental to its character, and the choice to be human-centered is unapologetic, because this decision can help students understand how to apply the material in their daily working life, help a broader range of students see themselves in their work, help students access the most up-to-date research in the field, and even help prepare students for future research careers. At the same time, I am aware that some students are not used to engaging with their own personal identities in a computer science classroom, nor the potential for political discourse that comes with discussion of social issues in the classroom. We will engage with potentially-personal topics, but will do so in a professional and academic way, where what matters is whether you demonstrate mastery of the works we study, not your personal belief.

Classroom activities:
* I recommend that instructors start the first day of class by sharing a written classroom climate statement, which is often part of the syllabus. This statement should come from the heart and should not be boilerplate. My own statement usually speaks from my positionality as a disabled trans woman to remind students that they belong in my classroom, establishes mental health as a priority, and sets the expectation that students are to go out of their way to make one another feel welcome in the classroom, and that students should question me openly while showing respect for my expertise. In the discussion of mental health, I inform students of mental health resources contained in the syllabus.
* Make time on the first day to go over relevant syllabus information. Office hours and other supports should be explained in a way that emphasizes students should seek help whenever that help could be useful, not only when they have a narrow specific question or when they have exhausted every possible option. Waitlist status should be discussed, as should software and tooling questions.
* The first day should include social interaction. I have student introduce themselves I encourage but do not require students to share pronouns (so as not to put pressure on closeted students). I will start group discussions by asking students to share (i.e. vent) past experiences with and current opinions on different programming languages.
* To the extent possible, leave time to install relevant software in class, and provide technical support for the installation process.

Exercises
* Review the following list of learning objectives for the book: Identify problems where programming language design can be used, Communicate with clarity and technical depth about language design, Develop a mathematically-precise definition of a language’s syntax, Develop a mathematically-precise definition of a language’s semantics, Implement interpreters for programming languages, and Situate your own work among the schools of thought discussed in class. Which of these objectives interest you the most? What objectives of your own do you have, which are not on this list? Skim through the chapters of the book and identify any material in the book which might help support your objectives. Share your objectives and interests with the course staff.
* Maintain a list of questions you have about programming languages in your daily life. As you continue through the book, try to elaborate these questions into a style that can be solved rigorously, such as falsifiable questions that could be studied experimentally or subjective questions which could be justified from reasoning from well-stated assumptions.


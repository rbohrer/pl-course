Lecture 22: Penrose

Reading: https://dl.acm.org/doi/pdf/10.1145/3386569.3392375
Authorship note: the first author's first name is Kai. Ignore the name in the paper. I looked for a version with the
correct name and could not find one.

This paper is about Penrose, a domain-specific language
for mathematical diagrams, published in 2020. In many ways
Penrose is the counterpart to Processing. Processing was
about teaching visual artists to code for the purpose of
making art, whereas Penrose is about teaching programmers
and mathematicians to develop beautiful visuals in support
of their mathematical work. My hope in comparing these
languages is that we might see how the difference in
audience leads to major differences between the two PLs
despite superficial appearance of similarity.


The paper opens with a motivating quote: 
"Mathematicians usually have fewer and poorer figures
in their papers and books than in their heads."
—William Thurston

Mathematicians have much to say, but are rarely trained in
how to say it, i.e., are rarely trained in typesetting of
professional diagrams. This is important for education and
mathematics communication in general; breakthroughs in
math are only impactful if they can be communicated.

In the authors' own words, Penrose is designed around the
distinction between abstract mathematical definitions and
concrete visual representation, with the goal of
supporting:
- Separation between content and presentation
- Accessibility toward new users
- Evolvability
- Scalability

Of these, only accessibility for new users is a clear
overlap of goals with Processing, and even that goal
should be expected to lead to different designs outcomes
given the different audience.

In-class: Go over the first diagram in the Penrose paper.

Here is the Penrose source code for that diagram:

Point p,q,r,s
Segment a := {p,q}
Segment b := {p,r}
Point m := Midpoint(a)
Angle theta := ∠(q,p,r)
Triangle t := {p,r,s}
Ray w := Bisector(theta)
Ray h := PerpendicularBisector(a)

The first line is a *declaration*, which states that four
points exist, but allows them to be arbitrary points.
All the remaining lines are *definitions*, indicated by
the assignment symbol (written :=). It is important to
note however that definitions in Penrose are radically
different from those in most programming languages,
because they do not uniquely determine the final presentation
of a diagram. More radically yet, definitions can refer to
elements that are only declared, not defined. The definitions
"a" and "b" define new segments in terms of points which have
no definition, only a declaration. In typical imperative and
functional languages, this sort of thing is impossible. We can
write programs that are quite underdefined.

What does the program do, then? It creates a triangle PRS,
marks the angle qpr, bisects it, and draws a perpendicular
bisector through the midpoint of segment PQ. I have only
described content, so what does the presentation look like?

The point is that the same content can have multiple
presentations. The figure in the paper is presented in 3
different styles corresponding to different sets of geometric
axioms: Euclidean geometry, spherical, and hyperbolic. One can
imagine different styles being used to support different devices,
languages, and disabilities without changing content.

* Informal syntax: Types, Predicates, Functions

* Informal semantics: Constraints
When we want to know "what does the program do?" we typically
look to the program semantics for answers. Penrose does not
define a formal mathematical semantics such as an operational
semantics, only an informal semantics.


* Virtual Machines
* Constraint-Satisfaction Programming
* Cascading Style Sheets
